# Stage 5 - Solution

## Substitution Failure is not An Error

In the problem page we've talked about the meaning of "substitution" in our context, but what does it mean "is not an error"?

From ["cppreference" on SFINAE](https://en.cppreference.com/w/cpp/language/sfinae.html#:~:text=This%20rule%20applies%20during%20overload%20resolution%20of%20function%20templates%3A%20When%20substituting%20the%20explicitly%20specified%20or%20deduced%20type%20for%20the%20template%20parameter%20fails%2C%20the%20specialization%20is%20discarded%20from%20the%20overload%20set%20instead%20of%20causing%20a%20compile%20error.):
> This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error.

In other words, if the compiler fails substituting the *template parameters* with the *template arguments*, it won't generate an error, but omit the failed substitution from his "overload set" and move on to the next one.

The "overload set" cppreference page discusses functions (and function templates), but, [according to the previous page](https://en.cppreference.com/w/cpp/language/sfinae.html#:~:text=SFINAE%20in%20partial,involving%20function%20templates.`):
> SFINAE in partial specializations
Deduction and substitution also occur while determining whether a specialization of a class or variable(since C++14) template is generated by some partial specialization or the primary template. A substitution failure is not treated as a hard-error during such determination, but makes the corresponding partial specialization declaration ignored instead, as if in the overload resolution involving function templates.

Meaning that the other partial specializations would be treated "as if in the overload resolution involving function templates".

> [!NOTE]
> This is a good example of how cppreference and documentations in general are often not as straight forward as we might expect, and how it takes some digging and time to grasp.

Let's start trying to implement our solution and understand how everything connects and works as we go.

## SimpleAlien - `decltype` and Instance Construction.

We might start by trying to implement using *variable templates*:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<Human::age, int>;
```

However, when we try to check it with `SimpleAlien` (which should result to true), we get the following error:

```
./try.cpp:15:56: error: invalid use of non-static data member ‘SimpleAlien::age’
   15 | constexpr bool is_human_like_v = std::is_same_v<Human::age, int>;
```

Which is understandable - `age` is a non-static data member of `SimpleAlien`.

So how about we create an instance of `SimpleAlien` and access it's `age` member - just to check things:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<Human().age, int>;
```

This also doesn't work:

```
./try.cpp:11:15:   required from here
./try.cpp:9:39: error: type/value mismatch at argument 1 in template parameter list for ‘template<class _Tp, class _Up> constexpr const bool std::is_same_v<_Tp, _Up>’
    9 | constexpr bool is_human_like_v = std::is_same_v<Human().age, int>;
./try.cpp:9:39: note:   expected a type, got ‘SimpleAlien{0}.SimpleAlien::age’
```

This also makes sense, the compiler tells us there's a type/value mismatch in the first argument of the `std::is_same` template.

He also hints us that he expected a type, but got... `SimpleAlien{0}.SimpleAlien::age`.

It's true that `Human().age`, the first template argument for `std::is_same` is not a type, but we want to get it's type.

In these cases, the `decltype` specifier comes in handy.

According to [cppreference on decltype](https://en.cppreference.com/w/cpp/language/decltype.html#:~:text=Inspects%20the%20declared%20type%20of%20an%20entity%20or%20the%20type%20and%20value%20category%20of%20an%20expression.):
> Inspects the declared type of an entity or the type and value category of an expression.

Basically, `decltype` "returns" (it's not a function, so it doesn't really return, more like "gets substitued with") the type of an expression / entity.

Using it in our case:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<decltype(Human().age), int>;
```

And checking it on `SimpleAlien` works!

Let's try it next on `Alien`.

## `is_human_like_v` on `Alien` (`std::declval`)

Trying to check our `is_human_like_v` on `Alien` results in the following error:

```
./try.cpp:20:58: error: use of deleted function ‘Alien::Alien()’
   20 | constexpr bool is_human_like_v = std::is_same_v<decltype(Human().age), int>;
```

And it makes sense - `Alien` deleted it's `Alien()` constructor, so we can't really use it.

We *can* change the implementation of our `is_human_like_v` to provide a dummy `int` value in the constructor, but then we would break the usage with `SimpleAlien`...

And in any case, we can't be prepared for all the constructors that might be out there!

`std::declval` comes in hany in cases like this.

From [cppreference on `std::declval`](https://en.cppreference.com/w/cpp/utility/declval.html#:~:text=Helper%20template%20for,go%20through%20constructors.):

> Helper template for writing expressions that appear in unevaluated contexts, typically the operand of decltype. In unevaluated context, this helper template converts any type T (which may be an incomplete type) to an expression of that type, making it possible to use member functions of T without the need to go through constructors.

We don't know what "unevaluated contexts" are, but "making it possible to use member functions of T without the need to go through constructors" sounds like what we need...

Let's try creating an instance using `std::declval` and use it:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<decltype(std::declval<Human>().age), int>;
```

As we expected, this works!

This way, we can access members of the type we receive without having to go through any specific constructors.

Let's move on to the next type we need to apply our "is human like" type-trait on - `VampireAlien`.


## Checking on `VampireAlien`

### Using Specializations for the Type Trait

This doesn't work, and we kind of could've expected it - it doesn't have a `int age` member, and so trying to access an unexisting member (tyring out duck typing) will result in the error:

```
./try.cpp:22:80: error: ‘struct VampireAlien’ has no member named ‘age’
   22 | constexpr bool is_human_like_v = std::is_same_v<decltype(std::declval<Human>().age), int>;
```

So we might have to use the "classical" type-trait technique we've used in the previous stages of having a default `false` implementation and other `true` specializations.

However, how do we verify that something *doesn't* exist? The absience of something?

As we've seen before, if we try accessing it, the compiler will result in a failure. But - "substitution failure is not an error", right?

We can try to use `SFINAE`, which we talked about earlier, to discard the `true_type` specialization and make the compiler choose the primary template for types that accessing their `age` member will result in a faiulure.

Let's try implementing the primary and specialization:

```c++
template<typename Human>
struct is_human_like : public std::false_type
{};

template<typename Human>
struct is_human_like<Human> : public std::true_type
{};
```

Before we even implemented the static assert, we get the following compilation error:

```
./try.cpp:28:8: error: partial specialization ‘struct is_human_like<Human>’ does not specialize any template arguments; to define the primary template, remove the template argument list
```

The compiler rightfully says that the specialization doesn't really specialize anything, and even instructs us to remove the *template argument list* (the `<Human>` that comes right after `is_human_like`) to create the primary template - it's thinking we want to define the primary tempalte and not a specialization...


### Forcing a Specialization

The problem is that we don't have a real "specialization" from the beginning, nor we want one... We just want the compiler to first try our specialization, and if that fails, only then to choose our primary template.

So how about we create a "fake" template parameter, one that we won't actually use, just to force the compiler to choose the specialization first?

```c++
template<typename Human, typename Dummy>
struct is_human_like : public std::false_type
{};

template<typename Human>
struct is_human_like<Human, void> : public std::true_type
{};
```

This way, when the user will use `is_human_like<VampireAlien>`, the specialiation will be automatically chosen, since it uses only one tepmlate argument (and gets the second type template argument from the specialization *template argument list*), right?

This sadly results in the following error:

```
./try.cpp:34:31: error: wrong number of template arguments (1, should be 2)
   34 |     static_assert(is_human_like<VampireAlien>::value, "");
```

This is also very true - the `is_human_like` accpets **two** *template arguments*, as dictated by the primary template.

Even if our specialization only needs one *template parameter*, when trying to instantiate the *class template*, 2 *template arguments* are requried.

In the case above, our specializtion would be chosen only if we call `is_human_like<VampireAlien, void>`, since this is the "specialized case".

However, we don't want to force the user to call `is_human_like<VampireAlient, void>`. Forcing such an API makes sense only if you know template metaprogramming. Also, it opens a huge place for errors - if the user will call `is_human_like` with anything other than `void`, the specialization would not be chosen by the compiler, which will choose the primary immediately.

Can we somehow automatically "insert" the `void` type as an argument when instantiating the *class template*? The same way we can automatically insert arguments without forcing the user to specify them - using *defaults arguments*, but for *template parameters*:

```c++
template<typename Human, typename Dummy = void>
struct is_human_like : public std::false_type
{};

template<typename Human>
struct is_human_like<Human, void> : public std::true_type
{};
```

This way, when calling `is_human_like<VampireAlien>`, the second `typename` parameter gets automatically substituted with the default argument `void`. Since the arguments to the template become `VampireAlien, void`, our specialization is more special than the primary template and thus gets chosen by the compiler.

> [!NOTE]
> This is still a bit error prone - if the user deliberately calls `is_human_like` with a second type not being `void`, the primary template will be automatically chosen.
>
> This case is still preferrable since the end-user API makes more sense and so hopefully will help preventing usage errors.

### Causing a Substitution Failure

Now that we've successfully forced the compiler to choose our specialization, we can fail it if there's no `int age` public member like we have in our previous implementation.

This time, however, we're using SFINAE and have the primary template to catch the failure before the whole compilation fails.

```c++
template<typename Human, typename Dummy = void>
struct is_human_like : public std::false_type
{};

template<typename Human>
struct is_human_like<Human, void> : public std::true_type
{
    static_assert(std::is_same_v<decltype(std::declval<Human>().age), int>, "");
};
```

Despite thinking that in case of a failure we would reach the primary tempalte, it seems like the compiler fails on the specialization, resulting in the following error:

```
./try.cpp:28:65: error: ‘struct VampireAlien’ has no member named ‘age’
   28 |     static_assert(std::is_same_v<decltype(std::declval<Human>().age), int>, "");
```

Why does "SFINAE" doesn't work here? Isn't *substitution failure* is not an error?

The answer is a part o the question - this is *not* a *substitution failure*.

Reaching the *implementation* of our partial specialization means the compiler has *already chosen* our partial implementation as the implementaion of `is_human_like`.

The compiler already successfully performed the substitution successfully.

SFINAE is Substitution Failure is not an Error, *not* Instantiation Failure is not an Error.

In order to use SFINAE to our advantage we have to cause a *substitution failure*.

Substitution is when arguments are put in place of parameters. We can cause substitution failures in the places in which arguments become parameters:

```c++
template <...>
struct my_struct</* template argument list: substitution failures here are not errors */> {
    // "Substitution failures" here are errors.
};
```

> [!NOTE]
> As a side note, these are the places we can cause substitution failures in *function tempalte*s:
> ```c++
> template<...>
> my_function</* template argument list: substitution failures here are not errors */>( /* function arguments: substitution failures here are not errors */) {
>     // "substitution failures" here are errors
> }
> ```
>
> Notice we have 2 places we can utilize substitution failures.

To conclude - we have to somehow check if our *type tepmalte parameter* has a public member `int age` in the substitution process in order to use SFINAE.


### `std::enable_if` to Cause Substitution Failure

From [cppreference on `std::enable_if`](https://en.cppreference.com/w/cpp/types/enable_if.html#:~:text=If%20B%20is,no%20member%20typedef.):

> ```c++
> template< bool B, class T = void >
> struct enable_if;
> ```
> If B is true, std::enable_if has a public member typedef type, equal to T; otherwise, there is no member typedef.

In other words, if the bool value of B (which is a bool type *constant template parameter*, so it has to be known at compile time) is `true`, the type `T` (which defaults to `void`) would be "returned". Otherwise, no type would be "returned".

Trying to access a `std::enable_if<...>::type` that doesn't exist would result in a failure, the same way we experienced in the beginning, when we've tried accessing the (unexisting) `age` public member of `VampireAlien` and caused a failure.


### Putting it all Together

We're under the following restrictions:
1. The failure has to be in the *template argument list* of our specialization.
2. A failure should happen in the case the given type doesn't have a public member `int age`.

And we have the following "abilities":
1. Return `true` if a type has a public member `int age` and *fail* (*not* return false) if it doesn't.
2. Return `void` if a certain condition results in `true`. Fail if the condition results in `false`.

Combining them results in:

```c++
template<typename Human>
struct is_human_like<
    Human, 
    typename std::enable_if<
        std::is_same<decltype(std::declval<Human>().age), int>::value
    >::type
> : public std::true_type
{};
```

Let's break it down:

1. The user calls `is_human_like<VampireAlien>`. This calls tries instantiating `is_human_like` with `Human = VampireAlien`.
2. Since the primary template is `template<typename, typename=void>`, the *template argument list* is `VampireAlien, void`.
3. The compiler tries substituting the partial specialization to see if it's more specialized than the primary template.
4. During substitution a failure occurs - `VampireAlien` doesn't have a public member `age`.
5. Because this is a part of the substitution, SFINAE is valid in this case, and so the compiler just goes to the next option it has, the primary template.
6. It tries instantiating the primary template successfully, and so the primary template's implementation is beind used for the instantiation of `is_human_like<VampireAlien>`.


Let's also try `is_human_like<Alien>` to make sure we haven't broken anything in the way:

1. The user calls `is_human_like<Alien>`. This calls tries instantiating `is_human_like` with `Human = Alien`.
2. Since the primary template is `template<typename, typename=void>`, the *template argument list* is `Alien, void`.
3. The compiler tries substituting the partial specialization to see if it's more specialized than the primary template.

> [!NOTE]
> Notice that the first 3 steps are completelly the same.

4. `decltype(std::declval<Human>().age)` yields `int`
5. The `std::is_same` returns `true`.
6. `enable_if` received `true` as the first *template argument*, so the instantiation's implementation will have a `using type = void`.
7. The specialization gets selected (since it's more special than the primary case, having `void` as the second *template argument*)
8. The instantiation will have a `public static constexpr bool value = true`.

### `WeirdAlien` and `VampireAlien`, 2 different substitution failures

Let's go trying to use `is_human_like` with `WeirdAlien`:

1. The first 3 steps are the same as the previous cases, so let's skip to the substitution.
2. This time `decltype` doesn't result in a failure but yields a type `char`.
3. `std::is_same` will have `value = false`, because `char` is not the same as `int`.
4. `std::is_same` will be instantiated with the first template argument being `false`.
5. `std::is_same` won't have a `using type` declaration inside of it's instantiation, and so trying to access one will result in a failure.
6. SFINAE happens, and the compiler results ot the primary template.
