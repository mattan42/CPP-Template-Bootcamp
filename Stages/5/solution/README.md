# Stage 5 - Solution

## Substitution Failure is not An Error

In the problem page we've talked about the meaning of "substitution" in our context, but what does it mean "is not an error"?

From ["cppreference" on SFINAE](https://en.cppreference.com/w/cpp/language/sfinae.html#:~:text=This%20rule%20applies%20during%20overload%20resolution%20of%20function%20templates%3A%20When%20substituting%20the%20explicitly%20specified%20or%20deduced%20type%20for%20the%20template%20parameter%20fails%2C%20the%20specialization%20is%20discarded%20from%20the%20overload%20set%20instead%20of%20causing%20a%20compile%20error.):
> This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error.

In other words, if the compiler fails substituting the *template parameters* with the *template arguments*, it won't generate an error, but omit the failed substitution from his "overload set" and move on to the next one.

The "overload set" cppreference page discusses functions (and function templates), but, [according to the previous page](https://en.cppreference.com/w/cpp/language/sfinae.html#:~:text=SFINAE%20in%20partial,involving%20function%20templates.`):
> SFINAE in partial specializations
Deduction and substitution also occur while determining whether a specialization of a class or variable(since C++14) template is generated by some partial specialization or the primary template. A substitution failure is not treated as a hard-error during such determination, but makes the corresponding partial specialization declaration ignored instead, as if in the overload resolution involving function templates.

Meaning that the other partial specializations would be treated "as if in the overload resolution involving function templates".

> [!NOTE]
> This is a good example of how cppreference and documentations in general are often not as straight forward as we might expect, and how it takes some digging and time to grasp.

Let's start trying to implement our solution and understand how everything connects and works as we go.

## SimpleAlien - `decltype` and Instance Construction.

We might start by trying to implement using *variable templates*:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<Human::age, int>;
```

However, when we try to check it with `SimpleAlien` (which should result to true), we get the following error:

```
./try.cpp:15:56: error: invalid use of non-static data member ‘SimpleAlien::age’
   15 | constexpr bool is_human_like_v = std::is_same_v<Human::age, int>;
```

Which is understandable - `age` is a non-static data member of `SimpleAlien`.

So how about we create an instance of `SimpleAlien` and access it's `age` member - just to check things:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<Human().age, int>;
```

This also doesn't work:

```
./try.cpp:11:15:   required from here
./try.cpp:9:39: error: type/value mismatch at argument 1 in template parameter list for ‘template<class _Tp, class _Up> constexpr const bool std::is_same_v<_Tp, _Up>’
    9 | constexpr bool is_human_like_v = std::is_same_v<Human().age, int>;
./try.cpp:9:39: note:   expected a type, got ‘SimpleAlien{0}.SimpleAlien::age’
```

This also makes sense, the compiler tells us there's a type/value mismatch in the first argument of the `std::is_same` template.

He also hints us that he expected a type, but got... `SimpleAlien{0}.SimpleAlien::age`.

It's true that `Human().age`, the first template argument for `std::is_same` is not a type, but we want to get it's type.

In these cases, the `decltype` specifier comes in handy.

According to [cppreference on decltype](https://en.cppreference.com/w/cpp/language/decltype.html#:~:text=Inspects%20the%20declared%20type%20of%20an%20entity%20or%20the%20type%20and%20value%20category%20of%20an%20expression.):
> Inspects the declared type of an entity or the type and value category of an expression.

Basically, `decltype` "returns" (it's not a function, so it doesn't really return, more like "gets substitued with") the type of an expression / entity.

Using it in our case:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<decltype(Human().age), int>;
```

And checking it on `SimpleAlien` works!

Let's try it next on `Alien`.

## `is_human_like_v` on `Alien` (`std::declval`)

Trying to check our `is_human_like_v` on `Alien` results in the following error:

```
./try.cpp:20:58: error: use of deleted function ‘Alien::Alien()’
   20 | constexpr bool is_human_like_v = std::is_same_v<decltype(Human().age), int>;
```

And it makes sense - `Alien` deleted it's `Alien()` constructor, so we can't really use it.

We *can* change the implementation of our `is_human_like_v` to provide a dummy `int` value in the constructor, but then we would break the usage with `SimpleAlien`...

And in any case, we can't be prepared for all the constructors that might be out there!

`std::declval` comes in hany in cases like this.

From [cppreference on `std::declval`](https://en.cppreference.com/w/cpp/utility/declval.html#:~:text=Helper%20template%20for,go%20through%20constructors.):

> Helper template for writing expressions that appear in unevaluated contexts, typically the operand of decltype. In unevaluated context, this helper template converts any type T (which may be an incomplete type) to an expression of that type, making it possible to use member functions of T without the need to go through constructors.

We don't know what "unevaluated contexts" are, but "making it possible to use member functions of T without the need to go through constructors" sounds like what we need...

Let's try creating an instance using `std::declval` and use it:

```c++
template<typename Human>
constexpr bool is_human_like_v = std::is_same_v<decltype(std::declval<Human>().age), int>;
```

As we expected, this works!

This way, we can access members of the type we receive without having to go through any specific constructors.

Let's move on to the next type we need to apply our "is human like" type-trait on - `VampireAlien`.


## Checking on `VampireAlien`

This doesn't work, and we kind of could've expected it - it doesn't have a `int age` member, and so trying to access an unexisting member (tyring out duck typing) will result in the error:

```
./try.cpp:22:80: error: ‘struct VampireAlien’ has no member named ‘age’
   22 | constexpr bool is_human_like_v = std::is_same_v<decltype(std::declval<Human>().age), int>;
```

So we might have to use the "classical" type-trait technique we've used in the previous stages of having a default `false` implementation and other `true` specializations.


